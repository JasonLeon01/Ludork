 # Ludork：2D RPG 工具包 - 帮助手册
 ## 概念与架构总览

 本章从概念层面介绍 Ludork 的整体结构。要高效使用这个工具包，并不需要理解所有内部细节，但了解主要构成部分以及它们之间的关系，会让你更容易理解自己的项目结构，也更容易把编辑器里看到的内容和游戏实际运行时的表现对应起来。

 从高层来看，Ludork 由四个互相协作的部分组成：
 - **编辑器（Editor）**：基于 PyQt5 的桌面应用，用于创建和管理游戏内容。
 - **运行时引擎（Runtime Engine）**：轻量的、基于 SFML 的核心，负责使用在编辑器中创建的数据来运行游戏。
 - **数据与资源（Data & Assets）**：保存地图、图块集、可视化脚本、配置以及媒体文件。
 - **性能扩展（Performance Extensions）**：一组原生（C/C++）模块，用于加速瓦片地图渲染、路径寻找等重计算操作。

 ### 编辑器（Editor）

 编辑器是创作者进入 Ludork 的主要入口，它提供：
 - 用于地图、图块集、事件以及可视化脚本的 Material 风格窗口界面。
 - 可停靠的面板，用于文件浏览、预览、控制台输出与调试信息。
 - 各类专用工具，例如图块集编辑器、地图编辑器、公共函数（节点图）编辑器、配置窗口等。

 从概念上看，编辑器主要负责：
 - 提供一套**可视化工具**，让原本复杂的 JSON 或二进制数据以图形方式呈现和修改。
 - 跟踪当前的**项目状态**：包括资产、配置以及当前打开的文档。
 - 将你的改动保存为结构化文件，写入项目的数据目录。

 当你在编辑器里点击按钮、拖动元素时，实际上就是在修改这些将被运行时引擎加载的数据。

 ### 运行时引擎（Runtime Engine）

 运行时引擎是实际“播放”你游戏内容的部分。它：
 - 通过 Python 绑定使用 SFML（Simple and Fast Multimedia Library），处理渲染、音频与输入。
 - 加载编辑器写出的同一批数据文件（地图、图块集、公共函数、配置等）。
 - 将这些数据解释为场景（scene）、瓦片地图、角色、粒子效果、UI 窗口以及玩法逻辑。

 从架构角度来看：
 - 运行时是**数据驱动**的：它不会把你的具体游戏内容写死在代码里，而是读取你在编辑器中构建的内容。
 - 它提供一组**核心系统**，例如游戏地图、摄像机、粒子系统、UI 组件、资源管理器以及时间/计时工具。
 - 它与编辑器对项目数据的理解保持一致，从而保证编辑时看到的结果能够尽量贴近实际运行效果。

 你可以把运行时看作一个轻量的引擎，它负责“播放”你在编辑器中创作的内容。

 ### 数据与资源（Data & Assets）

 在 Ludork 中，**数据（Data）**与**资源（Assets）**是刻意分开的：
 - 数据描述游戏是如何被组织起来的：配置项、地图定义、图块集元数据以及可视化脚本图等。
 - 资源是游戏实际使用的媒体文件：图片、音频、字体与着色器等。

 一个典型项目通常包含：
 - `Data` 目录，用于存放：
   - **Configs**：高层系统设置（标题、分辨率、着色器、字体选择等）。
   - **Maps**：瓦片地图图层、区域以及相关元数据。
   - **Tilesets**：描述图块集图片如何被使用的定义（例如图块尺寸、通行规则）。
   - **Common Functions**：以图形式存储的可视化脚本，可在多处复用。
 - `Assets`（或类似名称）目录，用于存放：
   - **角色、敌人和 NPC 的图像**。
   - **环境与背景的图块集图片**。
   - **音频资源**（背景音乐与音效）。
   - **着色器**（用于转场、色调调整以及后期效果）。
   - **系统 UI 资源**（窗口皮肤、图标等）。

 编辑器负责读写这些文件；运行时则加载它们来构建实际运行的游戏场景。

 ### 可视化脚本模型（Visual Scripting Model）

 Ludork 中的一个关键概念是**公共函数（Common Function）**：这是通过可视化节点图定义的一段可复用游戏逻辑，而不是直接书写代码。

 在概念层面上：
 - 每个公共函数都是一个由节点组成的**图（graph）**，节点之间通过连线相互连接。
 - 节点可以执行数学运算、字符串处理、容器操作，也可以与游戏相关的数据交互。
 - 输入与输出定义了数据在图中的流动方式。

 其工作流程是：
 - 在编辑器中，你使用节点图编辑器创建与修改这些图。
 - 这些图与项目中的其他内容一起被保存为数据文件。
 - 运行时引擎加载图的描述，构建可执行的图实例，并在需要时进行求值（例如用于驱动事件、计算、特效等）。

 这种可视化脚本模型让你在不直接编写 Python 代码的情况下也能构建复杂行为，同时又与引擎处理数据的方式保持紧密对应。

 ### 核心运行时概念（Core Runtime Concepts）

 运行时引擎暴露出若干贯穿编辑器各处的核心概念：
 - **场景与游戏地图（Scenes and Game Maps）**：表示可游玩的区域以及基于瓦片的布局。
 - **摄像机与视口（Camera and Viewport）**：控制屏幕上可见的地图区域以及呈现方式。
 - **角色与 UI 元素（Actors and UI Elements）**：角色、敌人、交互对象，以及窗口、文字框、图片等界面元素。
 - **粒子与特效（Particles and Effects）**：火花、光晕、法术等视觉效果。

 虽然你是在编辑器中通过各种工具操作这些概念，但它们在底层都对应着运行时中的系统，这些系统最终基于你创建的数据来运作。

 ### 性能扩展（Performance Extensions）

 在 2D RPG 中，有一些操作对性能非常敏感，特别是：
 - 绘制大规模瓦片地图。
 - 在地图上进行路径寻找与移动计算。
 - 每一帧更新大量粒子与视觉效果。

 为了保持编辑器响应灵敏、运行时帧率平稳，Ludork 使用了通过 C/C++ 实现的**原生扩展模块**。这些扩展：
 - 通过 pybind11 从 Python 中调用。
 - 更高效地完成瓦片地图渲染、游戏地图寻路等任务，相比纯 Python 有明显性能优势。
 - 同时被编辑器（用于预览与工具）和运行时引擎（用于游戏实际运行）所使用。

 作为使用者，你通常不需要直接与这些模块交互，只要知道部分重计算被交给了底层原生代码，从而保证体验足够流畅即可。

 ### 编辑器–运行时一致性（Editor–Runtime Parity）

 Ludork 的一个核心设计目标是**编辑器–运行时一致性**：即编辑器与运行时对项目数据有同样的理解。

 从实际效果上看，这意味着：
 - 编辑器使用的数据格式与运行时引擎使用的是同一套。
 - 当你在编辑器中调整地图、图块集或公共函数并保存后，运行时可以立刻加载并使用这些数据，而无需额外转换。
 - 编辑器中的可视化预览尽量贴近运行时的实际表现。

 对创作者来说，这种一致性减少了“编辑器里看到的”和“玩家实际看到的”之间的差距，从而缩短迭代时间，让整个工作流程更加可预期。
