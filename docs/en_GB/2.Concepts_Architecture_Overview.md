 # Ludork: 2D RPG Toolkit - Help Manual
 ## Concepts & Architecture Overview

 This chapter gives you a conceptual overview of how Ludork is structured. You do not need to understand every internal detail to use the toolkit effectively, but knowing the main pieces and how they relate to each other will make it easier to reason about your project and interpret what you see in the editor.

 At a high level, Ludork is made of four cooperating parts:
 - The **Editor**, a PyQt5-based desktop application where you create and manage game content.
 - The **Runtime Engine**, a lightweight SFML-powered core that runs your game using the data created in the editor.
 - The **Data & Assets**, which hold your maps, tilesets, visual scripts, configuration, and media files.
 - The **Performance Extensions**, a set of native (C/C++) modules that accelerate heavy operations such as tilemap rendering and pathfinding.

 ### Editor

 The editor is the main entry point for creators. It provides:
 - A material-themed, windowed interface for maps, tilesets, events, and visual scripts.
 - Dockable panels for file browsing, previews, console output, and debugging.
 - Specialized tools such as the Tileset Editor, Map Editor, Common Function (Node Graph) editor, configuration windows, and more.

 From a conceptual point of view, the editor is responsible for:
 - Presenting **visual tools** to edit data that would otherwise be stored as complex JSON or binary formats.
 - Keeping track of the **current project**: its assets, configuration, and open documents.
 - Saving your changes into structured files under the project’s data folders.

 When you click buttons or move things around in the editor, you are always manipulating data that will later be loaded by the runtime engine.

 ### Runtime Engine

 The runtime engine is the part that actually plays your game. It:
 - Uses SFML (Simple and Fast Multimedia Library) through Python bindings to handle rendering, audio, and input.
 - Loads the same data files the editor writes (maps, tilesets, common functions, configuration).
 - Interprets that data as scenes, tilemaps, actors, particles, UI windows, and gameplay logic.

 From an architectural perspective:
 - The runtime is **data-driven**: it does not hard-code your game, but instead reads the content you built in the editor.
 - It provides **core systems** such as the game map, camera, particle system, UI widgets, resource managers, and timing utilities.
 - It mirrors the editor’s understanding of the project so that what you see while editing matches what you experience when running the game.

 You can think of the runtime as a lightweight engine that “plays back” the content authored with the editor.

 ### Data & Assets

 Ludork separates **data** (structured information) from **assets** (media files):
 - **Data** describes how your game is put together: configuration values, map definitions, tileset metadata, and visual script graphs.
 - **Assets** are the actual images, sounds, fonts, and shaders used by the game.

 A typical project includes:
 - A `Data` folder for:
   - **Configs**: high-level system settings (title, resolution, shaders, font selections, etc.).
   - **Maps**: tilemap layers, regions, and related metadata.
   - **Tilesets**: definitions that describe how tileset images are used (e.g., tile size, passability).
   - **Common Functions**: visual scripts stored as reusable graphs for logic and effects.
 - An `Assets` folder (or similar) for:
   - **Characters, enemies, and NPC sprites**.
   - **Tileset images** for environments and backgrounds.
   - **Audio** (music and sound effects).
   - **Shaders** for transitions, tone adjustments, and post-processing.
   - **System UI assets** such as window skins and icons.

 The editor reads and writes these files; the runtime loads them to build the live game scene.

 ### Visual Scripting Model

 A key concept in Ludork is the **Common Function**, a piece of reusable game logic defined using a visual node graph rather than handwritten code.

 Conceptually:
 - Each common function is a **graph** of nodes connected by links.
 - Nodes may perform math, manipulate strings, work with containers, or interact with game-specific data.
 - Inputs and outputs define how data flows through the graph.

 The workflow is:
 - In the editor, you create and modify graphs using the Node Graph editor.
 - These graphs are saved into data files alongside your other project content.
 - The runtime engine loads the graph descriptions, constructs executable graph instances, and evaluates them when needed (for example, to drive events, calculations, or effects).

 This visual scripting model lets you build sophisticated behaviors without needing to write Python code directly, while still mapping closely to how the engine processes data at runtime.

 ### Core Runtime Concepts

 The runtime engine exposes several core concepts that appear throughout the editor:
 - **Scenes and Game Maps**: represent the playable areas and their tile-based layout.
 - **Camera and Viewport**: control which part of the map is visible on screen and how it is framed.
 - **Actors and UI Elements**: characters, enemies, and interactive objects, plus windows, text boxes, and images used for the interface.
 - **Particles and Effects**: visual effects such as sparks, light glows, or spell animations.

 Even though you manipulate these concepts with editor tools, they all correspond to underlying runtime systems that operate on the data you create.

 ### Performance Extensions

 Some operations in a 2D RPG can be very performance‑sensitive, especially:
 - Drawing large tilemaps.
 - Computing pathfinding and movement across a map.
 - Updating many particles and visual effects every frame.

 To keep the editor responsive and the runtime smooth, Ludork uses **native extensions** implemented in C/C++. These extensions:
 - Are accessed from Python via pybind11.
 - Handle tasks such as tilemap rendering and game map pathfinding more efficiently than pure Python.
 - Are used both by the editor (for previews and tooling) and by the runtime engine (for actual gameplay).

 As a user, you do not need to interact with these modules directly. It is enough to understand that some heavy operations are offloaded to native code to keep the experience fast.

 ### Editor–Runtime Parity

 A central design goal of Ludork is **editor–runtime parity**: the idea that the editor and the runtime share the same understanding of project data.

 In practical terms, this means:
 - Data formats used by the editor are the same ones used by the runtime engine.
 - When you adjust a map, tileset, or common function in the editor and save it, the runtime can immediately load and use that data without conversion.
 - Visual previews in the editor are designed to match runtime behavior as closely as possible.

 For you as a creator, editor–runtime parity reduces the gap between “what I see in the editor” and “what players see in the final game”, which in turn shortens iteration times and makes the overall workflow more predictable.
