 # Ludork: 2D RPG Toolkit - Help Manual
 ## Visual Scripting with Node Graph

 This chapter explains how to use Ludork’s visual scripting system, built around **Common Functions** and a **Node Graph** editor. Visual scripting lets you create and reuse gameplay logic without writing Python code directly.

 ### Common Functions Overview

 A **Common Function** is a reusable unit of logic represented as a graph of nodes:
 - Each node performs a small operation (math, string manipulation, container operations, etc.).
 - Connections between nodes define how data flows and in what order operations occur.
 - Inputs and outputs define what the function needs and what it produces.

 Common Functions are stored as data files under the Project’s `Data/CommonFunctions` area and can be used in multiple places in your game.

 ### Node Graph Editor

 You edit Common Functions using the **Node Graph editor**, which provides:
 - A **graph canvas** where nodes are placed and connected.
 - A **Common Function list** or browser to select which function you are editing.
 - Panels for inspecting node properties, inputs, outputs, and parameters.

 From a user’s perspective:
 - The canvas behaves like other node‑based tools: you drag nodes into the view, connect them with lines, and rearrange them as needed.
 - The editor keeps track of which Common Function is currently active and marks it as modified when you make changes.

 When you save, the editor writes the updated graph description back to the corresponding file in `Data/CommonFunctions`.

 ### Creating and Managing Common Functions

 To create a new Common Function:
 - Open the Common Function management window from the editor.
 - Add a new entry and give it a clear, descriptive name.
 - Open it in the Node Graph editor.

 To manage existing functions:
 - Use the list or browser to select a function.
 - Duplicate functions if you want to create variations without starting from scratch.
 - Remove functions that are no longer needed, taking care to update any references in gameplay logic.

 Consistent naming and organization make it easier to navigate your Project as the number of Common Functions grows.

 ### Node Types and Categories

 The Node Graph editor provides a variety of node types, typically organized into categories such as:
 - **Math**: arithmetic, comparisons, and other numeric operations.
 - **String**: concatenation, formatting, and substring operations.
 - **Containers**: lists, dictionaries, and other data structures.
 - **Utils**: utility operations such as clamping values or random number generation.
 - **Project‑specific nodes**: nodes that interact with your game’s data (maps, actors, UI elements, etc.).

 When building a Common Function:
 - Choose nodes from these categories to assemble the behavior you need.
 - Combine generic nodes (math, string, containers) with project‑specific nodes to implement practical gameplay logic.

 ### Inputs and Outputs

 Every Common Function can define:
 - **Inputs**, which are values supplied from outside the graph when it runs.
 - **Outputs**, which are values the graph calculates and returns.

 In the Node Graph editor:
 - You can add or remove inputs and outputs to match what the function is supposed to do.
 - Input nodes represent external values; output nodes collect and expose results.

 Clear input and output design makes Common Functions easier to reuse:
 - A function with well‑defined inputs can be used in multiple contexts.
 - A function with clear outputs can be chained into other logic or used by UI and effects.

 ### Flow and Execution

 Visual scripting in Ludork is data‑driven, but many graphs also have an implicit or explicit notion of execution flow. In practice:
 - Some nodes operate purely on data (for example, transforming numbers or strings).
 - Other nodes may represent actions or steps in a sequence (for example, triggering an effect or updating a value).

 The Node Graph editor allows you to:
 - Connect nodes in a way that reflects the intended order of operations.
 - Use conditional nodes (comparisons, branching) to create different paths based on input data.

 At runtime, the engine evaluates the graph according to these connections and node types, producing the outputs defined by the Common Function.

 ### Using Common Functions in Your Game

 Once defined, Common Functions can be invoked from various parts of your game, for example:
 - As part of event logic.
 - To compute values such as damage, rewards, or movement costs.
 - To control effects, transitions, or UI behavior.

 Although the details depend on how your project is structured, the general pattern is:
 - You configure a piece of gameplay to call a specific Common Function.
 - When that part of the game runs, the engine:
   - Supplies the required inputs to the function.
   - Evaluates the Node Graph.
   - Uses the outputs to decide what happens next.

 Because Common Functions are pure data, you can iterate on them in the editor without changing engine code.

 ### Organizing Your Graphs

 As your Project grows, you will likely accumulate many Common Functions. To keep them manageable:
 - Group related functions by naming convention (for example, `Battle/`, `UI/`, `Map/` prefixes).
 - Prefer smaller, focused functions that do one thing well.
 - Reuse functions by calling them from other graphs where supported, rather than duplicating logic.

 This approach makes it easier to debug and maintain your project’s behavior over time.

 ### Debugging and Iteration

 Visual scripting is designed for rapid iteration:
 - You can modify graphs and test changes without touching Python code.
 - Errors in logic are often easier to spot visually than in text form.

 To debug Common Functions:
 - Use the editor’s console and logging features to observe how your game behaves when a function runs.
 - Adjust node connections or parameters and re‑test until the behavior matches your intent.

 Because the editor and runtime share the same data formats, changes you make to graphs can be reflected in gameplay with minimal friction.

